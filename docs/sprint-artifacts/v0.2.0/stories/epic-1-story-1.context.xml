<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1</storyId>
    <title>Add Prompt Mode to Manifest Schema</title>
    <status>drafted</status>
    <generatedAt>2025-11-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/planning/v0.2.0/stories/epic-1-story-1.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>the manifest to support prompt mode discrimination</iWant>
    <soThat>configs can represent either engine-based or theme-based prompts</soThat>
    <tasks>
      - Implement `prompt_mode` enum field in manifest schema
      - Add conditional fields for engine vs theme modes
      - Implement backward compatibility for existing manifests
      - Update validation logic for new schema
      - Create comprehensive tests
    </tasks>
  </story>

  <acceptanceCriteria>
    - [ ] Add `prompt_mode` field to `[profile]` section (enum: "prompt_engine" | "framework_theme")
    - [ ] Add `prompt_engine` field (optional, used when mode = "prompt_engine")
    - [ ] Rename `theme` field to `framework_theme` (optional, used when mode = "framework_theme")
    - [ ] Implement backward compatibility (old manifests default to `framework_theme`)
    - [ ] Update validation to ensure only one is set based on mode
    - [ ] Update tests for new schema
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/planning/v0.2.0/epic-1-smart-tui.md</path>
        <title>Epic 1: Smart TUI (Prompt Mode Branching)</title>
        <section>Technical Design - Data Model</section>
        <snippet>Defines PromptMode enum structure with PromptEngine and FrameworkTheme variants, showing how manifest should discriminate between standalone engines and framework themes. Includes TOML examples for both modes.</snippet>
      </doc>
      <doc>
        <path>docs/planning/v0.2.0/epic-1-smart-tui.md</path>
        <title>Epic 1: Smart TUI</title>
        <section>TOML Examples</section>
        <snippet>Shows example manifests with prompt_mode="prompt_engine" using prompt_engine="starship", and prompt_mode="framework_theme" using framework_theme="robbyrussell".</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>src/core/manifest.rs</path>
        <kind>module</kind>
        <symbol>Manifest, ProfileSection</symbol>
        <lines>1-613</lines>
        <reason>Core manifest structure that needs to be extended with prompt_mode enum and related fields. Currently has ProfileSection with theme field (line 33) that needs to be refactored to framework_theme with prompt mode discrimination.</reason>
      </artifact>
      <artifact>
        <path>src/core/manifest.rs</path>
        <kind>struct</kind>
        <symbol>ProfileSection</symbol>
        <lines>28-38</lines>
        <reason>The profile section currently has a simple `theme: String` field (line 33) that needs to be replaced with prompt_mode enum and conditional theme/engine fields.</reason>
      </artifact>
      <artifact>
        <path>src/core/manifest.rs</path>
        <kind>function</kind>
        <symbol>validate</symbol>
        <lines>108-156</lines>
        <reason>Validation function that needs to be extended to ensure only one of prompt_engine or framework_theme is set based on prompt_mode value.</reason>
      </artifact>
      <artifact>
        <path>src/core/manifest.rs</path>
        <kind>function</kind>
        <symbol>from_framework_info</symbol>
        <lines>70-86</lines>
        <reason>Constructor that creates manifests from detected frameworks - needs to set prompt_mode to framework_theme for backward compatibility.</reason>
      </artifact>
      <artifact>
        <path>src/core/manifest.rs</path>
        <kind>tests</kind>
        <symbol>tests module</symbol>
        <lines>239-613</lines>
        <reason>Comprehensive test suite for manifest parsing and validation. Need to add tests for new prompt_mode field, backward compatibility, and validation of mode-specific fields.</reason>
      </artifact>
    </code>

    <dependencies>
      <rust>
        <package name="serde" version="1.0" purpose="Serialization/deserialization for TOML manifest"/>
        <package name="toml" version="0.9" purpose="TOML parsing and generation"/>
        <package name="chrono" version="0.4" purpose="Timestamp handling in manifest"/>
        <package name="anyhow" version="1.0" purpose="Error handling"/>
      </rust>
      <dev-dependencies>
        <package name="insta" version="1.34" purpose="Snapshot testing for manifest structure"/>
        <package name="tempfile" version="3.8" purpose="Testing with temporary manifest files"/>
      </dev-dependencies>
    </dependencies>
  </artifacts>

  <constraints>
    - Must maintain backward compatibility: existing manifests without prompt_mode should default to framework_theme mode
    - Use Rust enum for prompt_mode to ensure type safety at compile time
    - Follow existing serde patterns in the codebase for enum serialization
    - Keep validation logic centralized in the validate() method
    - Maintain comprehensive error messages with examples (as seen in existing validation)
    - Use #[serde(default)] for optional fields to handle missing values gracefully
    - Follow Pattern 4: TOML Manifest Schema as documented
  </constraints>

  <interfaces>
    <interface>
      <name>PromptMode enum</name>
      <kind>Rust enum (to be created)</kind>
      <signature>pub enum PromptMode { PromptEngine { engine: String }, FrameworkTheme { theme: String } }</signature>
      <path>src/core/manifest.rs</path>
      <notes>New enum type to discriminate between prompt engine and framework theme modes</notes>
    </interface>
    <interface>
      <name>ProfileSection struct</name>
      <kind>Rust struct (to be modified)</kind>
      <signature>pub struct ProfileSection { name: String, framework: String, prompt_mode: PromptMode, ... }</signature>
      <path>src/core/manifest.rs</path>
      <notes>Needs to replace simple `theme` field with `prompt_mode` enum that contains mode-specific data</notes>
    </interface>
    <interface>
      <name>Manifest::validate</name>
      <kind>validation method</kind>
      <signature>pub fn validate(&self) -> Result<()></signature>
      <path>src/core/manifest.rs (lines 108-156)</path>
      <notes>Needs extension to validate prompt_mode enum variants and ensure correct field usage</notes>
    </interface>
  </interfaces>

  <tests>
    <standards>
      The codebase uses comprehensive unit testing with Rust's built-in test framework. Tests are located in a #[cfg(test)] mod tests block within the same file. Validation tests check both success and failure cases with detailed error message assertions. Integration tests use tempfile for filesystem operations and insta for snapshot testing of TOML output.
    </standards>
    <locations>
      - Unit tests: src/core/manifest.rs #[cfg(test)] mod tests (lines 239-613)
      - Integration tests: tests/*_test.rs files
    </locations>
    <ideas>
      <test ac="Add prompt_mode field">
        <idea>Test parsing manifest with prompt_mode="prompt_engine" and prompt_engine field set</idea>
        <idea>Test parsing manifest with prompt_mode="framework_theme" and framework_theme field set</idea>
        <idea>Test TOML serialization includes correct prompt_mode value</idea>
      </test>
      <test ac="Backward compatibility">
        <idea>Test parsing old manifest without prompt_mode defaults to framework_theme mode</idea>
        <idea>Test old manifest with "theme" field migrates to "framework_theme"</idea>
        <idea>Test from_framework_info sets prompt_mode to framework_theme by default</idea>
      </test>
      <test ac="Validation">
        <idea>Test validation rejects prompt_mode="prompt_engine" without prompt_engine field</idea>
        <idea>Test validation rejects prompt_mode="framework_theme" without framework_theme field</idea>
        <idea>Test validation allows empty theme when using prompt engine mode</idea>
        <idea>Test validation enforces exactly one of engine or theme based on mode</idea>
      </test>
      <test ac="Roundtrip">
        <idea>Test manifest with prompt_mode roundtrips correctly through TOML serialization</idea>
        <idea>Test all prompt_mode variants serialize/deserialize correctly</idea>
      </test>
    </ideas>
  </tests>
</story-context>
