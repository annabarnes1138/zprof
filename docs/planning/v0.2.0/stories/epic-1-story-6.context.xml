<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>6</storyId>
    <title>Update Generator for Prompt Engines</title>
    <status>drafted</status>
    <generatedAt>2025-11-21</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/planning/v0.2.0/stories/epic-1-story-6.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>the generator to handle prompt engines correctly</iWant>
    <soThat>shell configs initialize engines instead of framework themes</soThat>
    <tasks>
- Modify src/shell/generator.rs to handle prompt modes (PromptEngine: disable framework theme, add engine init; FrameworkTheme: use existing logic)
- Create prompt engine installer: src/prompts/installer.rs with Binary download, Git clone, Framework plugin methods
- Add engine initialization during profile creation (install, configure path, add init command to .zshrc)
- Validate generated configs (zsh -n syntax check, no conflicts, verify initialization order)
- Add comprehensive tests (5 engines × 3 frameworks = 15 tests, snapshot tests, integration tests, error handling)
- Handle edge cases (already installed, Nerd Font warnings, cross-shell compatibility)
- Add rollback mechanism (installation failure fallback, cleanup, error logging)
    </tasks>
  </story>

  <acceptanceCriteria>
- [ ] Modify src/shell/generator.rs to handle PromptEngine vs FrameworkTheme modes
- [ ] Create src/prompts/installer.rs with Binary, Git, Framework plugin installation methods
- [ ] Add engine initialization during profile creation
- [ ] Validate generated configs with zsh -n
- [ ] Test all 15 engine × framework combinations
- [ ] Handle edge cases (already installed, Nerd Font warnings)
- [ ] Add rollback mechanism for failed installations
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/planning/v0.2.0/epic-1-smart-tui.md</path>
        <title>Epic 1: Smart Prompt Selection</title>
        <section>Story 1.6: Update Generator for Prompt Engines</section>
        <snippet>Modify shell generator to handle prompt engines (disable framework themes, add engine initialization). Create engine installer supporting binary downloads, git clones, framework plugins. Validate configs, test all combinations.</snippet>
      </doc>
      <doc>
        <path>docs/developer/architecture.md</path>
        <title>Architecture Overview</title>
        <section>Shell Generation</section>
        <snippet>Shell configs (.zshrc/.zshenv) are generated artifacts from profile.toml manifest. Generator creates framework-specific configs, validates with zsh -n. Initialization order: framework → plugins → custom.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/shell/generator.rs</path>
        <kind>module</kind>
        <symbol>ShellGenerator</symbol>
        <lines>N/A</lines>
        <reason>Core generator needing modification to branch on PromptMode (engine vs theme), disable framework themes for engines, add engine initialization</reason>
      </artifact>
      <artifact>
        <path>src/core/manifest.rs</path>
        <kind>module</kind>
        <symbol>PromptMode enum</symbol>
        <lines>N/A</lines>
        <reason>PromptMode enum from Story 1.1, used to determine generator behavior</reason>
      </artifact>
      <artifact>
        <path>src/prompts/engine.rs</path>
        <kind>module</kind>
        <symbol>PromptEngine registry</symbol>
        <lines>N/A</lines>
        <reason>Prompt engine registry from Story 1.3, provides engine metadata and init commands</reason>
      </artifact>
      <artifact>
        <path>src/frameworks/oh_my_zsh.rs</path>
        <kind>module</kind>
        <symbol>generate_config</symbol>
        <lines>N/A</lines>
        <reason>Framework-specific config generation, need to handle ZSH_THEME="" for engine mode</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="dirs" version="5.0" note="Already present, used for home directory detection in installer" />
        <package name="anyhow" version="2.0" note="Already present, error handling" />
      </rust>
      <system>
        <requirement name="git" note="Required for git clone installations (Pure, Spaceship, Powerlevel10k)" />
        <requirement name="curl or wget" note="Required for binary downloads (Starship, Oh My Posh)" />
        <requirement name="zsh" note="Required for syntax validation (zsh -n)" />
      </system>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Framework theme must be explicitly disabled when using prompt engine (ZSH_THEME="" for oh-my-zsh, zstyle off for prezto)</constraint>
    <constraint>Initialization order is critical: framework initialization MUST complete before engine initialization</constraint>
    <constraint>All generated configs must pass zsh -n syntax validation before being written</constraint>
    <constraint>Installation methods vary by engine: Binary download (Starship, Oh My Posh), Git clone (Pure, Spaceship), Framework plugin (Powerlevel10k for oh-my-zsh)</constraint>
    <constraint>Rollback required on installation failure: clean up partial installations, offer framework theme fallback</constraint>
    <constraint>Edge case: If engine already installed, skip installation step but still configure init command</constraint>
    <constraint>Nerd Font requirement: Warn user before installation if engine requires Nerd Font (Powerlevel10k, Starship with icons)</constraint>
    <constraint>Test coverage: All 15 combinations (5 engines × 3 frameworks) must have passing tests</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>ShellGenerator API</name>
      <kind>module</kind>
      <signature>impl ShellGenerator { pub fn generate_zshrc(&self) -> Result&lt;String&gt; }</signature>
      <path>src/shell/generator.rs</path>
    </interface>
    <interface>
      <name>EngineInstaller API</name>
      <kind>module</kind>
      <signature>impl EngineInstaller { pub fn install(&self, engine: &PromptEngine) -> Result&lt;()&gt;, pub fn is_installed(&self, engine: &PromptEngine) -> Result&lt;bool&gt; }</signature>
      <path>src/prompts/installer.rs</path>
    </interface>
    <interface>
      <name>PromptEngine Methods</name>
      <kind>trait-impl</kind>
      <signature>impl PromptEngine { pub fn install_method(&self) -> InstallMethod, pub fn init_command(&self) -> &'static str }</signature>
      <path>src/prompts/engine.rs</path>
    </interface>
  </interfaces>

  <tests>
    <standards>Comprehensive unit and integration tests. Snapshot tests for generated configs using insta crate. Test all 15 engine × framework combinations. Mock filesystem operations for unit tests. Integration tests with actual shell syntax validation.</standards>
    <locations>
      <location>tests/generator_test.rs</location>
      <location>tests/installer_integration_test.rs</location>
      <location>src/shell/generator.rs (inline unit tests)</location>
    </locations>
    <ideas>
      <test ac="Engine mode config generation">Unit: Generate config with PromptEngine mode, verify framework theme disabled (ZSH_THEME=""), engine init command present</test>
      <test ac="Theme mode config generation">Unit: Generate config with FrameworkTheme mode, verify theme set correctly, no engine init command</test>
      <test ac="All engine × framework combinations">Integration: Loop through 5 engines × 3 frameworks (15 total), generate config, validate with zsh -n, verify init command exists</test>
      <test ac="Starship installation">Integration (#[ignore] - network): Install Starship, verify binary in PATH, verify is_installed returns true</test>
      <test ac="Installation failure handling">Unit: Mock failed installation (network error), verify rollback, verify error returned</test>
      <test ac="Already installed skip">Unit: Mark engine as installed, call install, verify skips installation, no error</test>
      <test ac="Generated config snapshot">Snapshot: Generate Starship+oh-my-zsh config, use insta::assert_snapshot to verify output matches expected</test>
    </ideas>
  </tests>
</story-context>
