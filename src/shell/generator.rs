//! Shell configuration generator
//!
//! Generates .zshrc and .zshenv files from profile manifest data.
//! Handles framework-specific configuration differences.

use anyhow::{Context, Result};
use std::path::Path;

use crate::frameworks::FrameworkType;

/// Generate .zshrc and .zshenv files from wizard selections
///
/// # Arguments
///
/// * `profile_path` - The profile directory path
/// * `framework` - Selected framework type
/// * `plugins` - List of selected plugins
/// * `theme` - Selected theme name
pub fn generate_shell_configs(
    profile_path: &Path,
    framework: &FrameworkType,
    plugins: &[String],
    theme: &str,
) -> Result<()> {
    generate_zshrc(profile_path, framework, plugins, theme)?;
    generate_zshenv(profile_path)?;
    Ok(())
}

/// Generate .zshrc file with framework initialization
fn generate_zshrc(
    profile_path: &Path,
    framework: &FrameworkType,
    plugins: &[String],
    theme: &str,
) -> Result<()> {
    let mut content = String::new();

    // Header comment
    content.push_str("# Auto-generated by zprof from profile.toml\n");
    content.push_str("# DO NOT EDIT - Changes will be overwritten\n");
    content.push_str("# Edit profile.toml and run 'zprof edit <profile>' instead\n\n");

    // Framework-specific initialization
    match framework {
        FrameworkType::OhMyZsh => {
            content.push_str(&format!("export ZSH=\"$ZDOTDIR/.oh-my-zsh\"\n"));
            content.push_str(&format!("ZSH_THEME=\"{}\"\n", theme));
            content.push_str(&format!("plugins=({})\n", plugins.join(" ")));
            content.push_str("source $ZSH/oh-my-zsh.sh\n");
        }
        FrameworkType::Zimfw => {
            content.push_str("# zimfw initialization\n");
            content.push_str(&format!("zstyle ':zim:zmodule' home '$ZDOTDIR/.zimfw'\n"));
            for plugin in plugins {
                content.push_str(&format!("zmodule {}\n", plugin));
            }
            content.push_str(&format!("zmodule {}\n", theme));
            content.push_str("source $ZDOTDIR/.zimfw/zimfw.zsh\n");
        }
        FrameworkType::Prezto => {
            content.push_str("# prezto initialization\n");
            content.push_str("source $ZDOTDIR/.zprezto/init.zsh\n");
            content.push_str(&format!("zstyle ':prezto:module:prompt' theme '{}'\n", theme));
            content.push_str(&format!("zstyle ':prezto:load' pmodule {}\n",
                plugins.iter().map(|p| format!("'{}'", p)).collect::<Vec<_>>().join(" ")));
        }
        FrameworkType::Zinit => {
            content.push_str("# zinit initialization\n");
            content.push_str("source $ZDOTDIR/.zinit/bin/zinit.zsh\n");
            for plugin in plugins {
                content.push_str(&format!("zinit light {}\n", plugin));
            }
            content.push_str(&format!("zinit light {}\n", theme));
        }
        FrameworkType::Zap => {
            content.push_str("# zap initialization\n");
            content.push_str("[ -f $ZDOTDIR/.local/share/zap/zap.zsh ] && source $ZDOTDIR/.local/share/zap/zap.zsh\n");
            for plugin in plugins {
                content.push_str(&format!("plug \"{}\"\n", plugin));
            }
            content.push_str(&format!("plug \"{}\"\n", theme));
        }
    }

    let zshrc_path = profile_path.join(".zshrc");
    std::fs::write(&zshrc_path, content)
        .with_context(|| format!("Failed to write .zshrc to {}", zshrc_path.display()))?;

    Ok(())
}

/// Generate .zshenv file for environment variables
fn generate_zshenv(profile_path: &Path) -> Result<()> {
    let mut content = String::new();

    content.push_str("# Auto-generated by zprof from profile.toml\n\n");

    // Shared history configuration
    content.push_str("export HISTFILE=\"$HOME/.zsh-profiles/shared/.zsh_history\"\n");
    content.push_str("export HISTSIZE=10000\n");
    content.push_str("export SAVEHIST=10000\n");

    let zshenv_path = profile_path.join(".zshenv");
    std::fs::write(&zshenv_path, content)
        .with_context(|| format!("Failed to write .zshenv to {}", zshenv_path.display()))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_generate_zshrc_oh_my_zsh() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_zshrc(
            profile_path,
            &FrameworkType::OhMyZsh,
            &["git".to_string(), "docker".to_string()],
            "robbyrussell",
        )?;

        let zshrc_path = profile_path.join(".zshrc");
        let content = fs::read_to_string(&zshrc_path)?;

        assert!(content.contains("Auto-generated by zprof"));
        assert!(content.contains("export ZSH=\"$ZDOTDIR/.oh-my-zsh\""));
        assert!(content.contains("ZSH_THEME=\"robbyrussell\""));
        assert!(content.contains("plugins=(git docker)"));
        assert!(content.contains("source $ZSH/oh-my-zsh.sh"));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_zimfw() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_zshrc(
            profile_path,
            &FrameworkType::Zimfw,
            &["git".to_string(), "fzf".to_string()],
            "pure",
        )?;

        let zshrc_path = profile_path.join(".zshrc");
        let content = fs::read_to_string(&zshrc_path)?;

        assert!(content.contains("zimfw initialization"));
        assert!(content.contains("zmodule git"));
        assert!(content.contains("zmodule fzf"));
        assert!(content.contains("zmodule pure"));

        Ok(())
    }

    #[test]
    fn test_generate_zshenv() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_zshenv(profile_path)?;

        let zshenv_path = profile_path.join(".zshenv");
        let content = fs::read_to_string(&zshenv_path)?;

        assert!(content.contains("Auto-generated by zprof"));
        assert!(content.contains("export HISTFILE"));
        assert!(content.contains("export HISTSIZE=10000"));
        assert!(content.contains("export SAVEHIST=10000"));

        Ok(())
    }

    #[test]
    fn test_generate_shell_configs() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_shell_configs(
            profile_path,
            &FrameworkType::OhMyZsh,
            &["git".to_string()],
            "robbyrussell",
        )?;

        // Verify both files were created
        assert!(profile_path.join(".zshrc").exists());
        assert!(profile_path.join(".zshenv").exists());

        Ok(())
    }
}
