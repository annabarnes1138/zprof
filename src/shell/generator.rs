//! Shell configuration generator
//!
//! Generates .zshrc and .zshenv files from profile manifest data.
//! Handles framework-specific configuration differences.
//!
//! This module implements Story 2.2: Generate Shell Configuration from TOML
//! Generates .zshrc and .zshenv from ProfileManifest following Pattern 5.

use anyhow::{bail, Context, Result};
use chrono::Utc;
use std::fs;
use std::path::Path;
use std::time::Instant;

use crate::core::manifest::Manifest;
use crate::frameworks::FrameworkType;

/// Current zprof version for generated file headers
const ZPROF_VERSION: &str = env!("CARGO_PKG_VERSION");

/// Write generated .zshrc and .zshenv files from manifest (Story 2.2)
///
/// This is the main entry point for shell file generation from manifests.
/// It orchestrates the generation of both .zshrc and .zshenv files,
/// validates syntax, and ensures performance requirements are met.
///
/// # Arguments
///
/// * `profile_name` - The profile name (used to locate profile directory)
/// * `manifest` - The validated ProfileManifest containing configuration
///
/// # Errors
///
/// Returns an error if:
/// - Profile directory cannot be created
/// - File writes fail
/// - Generated files have syntax errors (when zsh is available)
/// - Generation takes longer than 1 second (logged as warning, not error)
///
/// # Performance
///
/// Must complete in under 1 second per AC #6
pub fn write_generated_files(profile_name: &str, manifest: &Manifest) -> Result<()> {
    let start = Instant::now();

    // Validate profile name to prevent path traversal attacks
    if profile_name.contains("..") || profile_name.contains('/') || profile_name.contains('\\') {
        bail!(
            "Invalid profile name '{}': cannot contain path traversal characters (.., /, \\)",
            profile_name
        );
    }

    // Get profile directory
    let profile_dir = dirs::home_dir()
        .context("Could not find home directory")?
        .join(".zsh-profiles")
        .join("profiles")
        .join(profile_name);

    // Ensure profile directory exists
    fs::create_dir_all(&profile_dir)
        .with_context(|| format!("Failed to create profile directory: {:?}", profile_dir))?;

    // Generate .zshenv
    let zshenv_content = generate_zshenv_from_manifest(manifest)?;
    let zshenv_path = profile_dir.join(".zshenv");
    fs::write(&zshenv_path, zshenv_content)
        .with_context(|| format!("Failed to write .zshenv to {:?}", zshenv_path))?;

    // Set explicit file permissions to 0644 (readable/writable by user, readable by others)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(&zshenv_path, fs::Permissions::from_mode(0o644))
            .with_context(|| format!("Failed to set permissions on {:?}", zshenv_path))?;
    }

    log::info!("Generated: {:?}", zshenv_path);

    // Generate .zshrc
    let zshrc_content = generate_zshrc_from_manifest(manifest)?;
    let zshrc_path = profile_dir.join(".zshrc");
    fs::write(&zshrc_path, zshrc_content)
        .with_context(|| format!("Failed to write .zshrc to {:?}", zshrc_path))?;

    // Set explicit file permissions to 0644 (readable/writable by user, readable by others)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(&zshrc_path, fs::Permissions::from_mode(0o644))
            .with_context(|| format!("Failed to set permissions on {:?}", zshrc_path))?;
    }

    log::info!("Generated: {:?}", zshrc_path);

    // Validate syntax (optional, requires zsh binary)
    validate_zsh_syntax(&zshrc_path)?;

    let duration = start.elapsed();
    log::debug!("Generation completed in {:?}", duration);

    // Should complete in under 1 second (AC #6)
    if duration.as_secs() >= 1 {
        log::warn!("Generation took longer than expected: {:?}", duration);
    }

    Ok(())
}

/// Generate .zshenv content from manifest (Story 2.2)
///
/// Creates .zshenv file with:
/// - Auto-generated header with timestamp and version
/// - Shared history configuration
/// - Environment variables from manifest with proper escaping
///
/// # Arguments
///
/// * `manifest` - The validated ProfileManifest
///
/// # Returns
///
/// String containing complete .zshenv content
pub fn generate_zshenv_from_manifest(manifest: &Manifest) -> Result<String> {
    let mut output = String::new();

    // Header comment (AC #3)
    output.push_str("# Auto-generated by zprof from profile.toml\n");
    output.push_str("# DO NOT EDIT THIS FILE DIRECTLY - Edit profile.toml instead\n");
    output.push_str(&format!("# Generated: {}\n", Utc::now().format("%Y-%m-%d %H:%M:%S")));
    output.push_str(&format!("# zprof version: {}\n", ZPROF_VERSION));
    output.push_str(&format!("# Profile: {}\n", manifest.profile.name));
    output.push_str("\n");

    // Shared history configuration
    output.push_str("# Shared command history across all profiles\n");
    output.push_str("export HISTFILE=\"$HOME/.zsh-profiles/shared/.zsh_history\"\n");
    output.push_str("export HISTSIZE=10000\n");
    output.push_str("export SAVEHIST=10000\n");
    output.push_str("\n");

    // Environment variables from manifest (AC #2)
    if !manifest.env.is_empty() {
        output.push_str("# Custom environment variables\n");
        for (key, value) in &manifest.env {
            // Escape quotes and special characters
            let escaped_value = escape_shell_value(value);
            output.push_str(&format!("export {}=\"{}\"\n", key, escaped_value));
        }
        output.push_str("\n");
    }

    Ok(output)
}

/// Escape shell special characters in environment variable values
///
/// Escapes: backslashes, double quotes, dollar signs, and backticks
/// This prevents shell injection and ensures values are interpreted literally
fn escape_shell_value(value: &str) -> String {
    value
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('$', "\\$")
        .replace('`', "\\`")
}

/// Generate .zshrc content from manifest (Story 2.2)
///
/// Creates framework-specific .zshrc file with:
/// - Auto-generated header with timestamp and version
/// - Framework initialization code
/// - Plugin loading
/// - Theme activation
///
/// # Arguments
///
/// * `manifest` - The validated ProfileManifest
///
/// # Returns
///
/// String containing complete .zshrc content
///
/// # Errors
///
/// Returns error if framework is not supported
pub fn generate_zshrc_from_manifest(manifest: &Manifest) -> Result<String> {
    let mut output = String::new();

    // Header comment (AC #3)
    output.push_str("# Auto-generated by zprof from profile.toml\n");
    output.push_str("# DO NOT EDIT THIS FILE DIRECTLY - Edit profile.toml instead\n");
    output.push_str(&format!("# Generated: {}\n", Utc::now().format("%Y-%m-%d %H:%M:%S")));
    output.push_str(&format!("# zprof version: {}\n", ZPROF_VERSION));
    output.push_str(&format!("# Profile: {}\n", manifest.profile.name));
    output.push_str(&format!("# Framework: {}\n", manifest.profile.framework));
    output.push_str("\n");

    // Generate framework-specific initialization (AC #1)
    match manifest.profile.framework.as_str() {
        "oh-my-zsh" => generate_oh_my_zsh_config(&mut output, manifest)?,
        "zimfw" => generate_zimfw_config(&mut output, manifest)?,
        "prezto" => generate_prezto_config(&mut output, manifest)?,
        "zinit" => generate_zinit_config(&mut output, manifest)?,
        "zap" => generate_zap_config(&mut output, manifest)?,
        _ => bail!("Unsupported framework: {}", manifest.profile.framework),
    }

    Ok(output)
}

/// Generate oh-my-zsh specific configuration
fn generate_oh_my_zsh_config(output: &mut String, manifest: &Manifest) -> Result<()> {
    output.push_str("# oh-my-zsh configuration\n");

    // Set ZSH path
    output.push_str("export ZSH=\"$ZDOTDIR/.oh-my-zsh\"\n");
    output.push_str("\n");

    // Set theme
    if !manifest.profile.theme.is_empty() {
        output.push_str(&format!("ZSH_THEME=\"{}\"\n", manifest.profile.theme));
    } else {
        output.push_str("ZSH_THEME=\"robbyrussell\"\n");
    }
    output.push_str("\n");

    // Set plugins
    if !manifest.plugins.enabled.is_empty() {
        output.push_str("plugins=(\n");
        for plugin in &manifest.plugins.enabled {
            output.push_str(&format!("  {}\n", plugin));
        }
        output.push_str(")\n");
        output.push_str("\n");
    }

    // Source oh-my-zsh
    output.push_str("source $ZSH/oh-my-zsh.sh\n");

    // Source shared customizations
    output.push_str("\n# Source shared customizations (edit ~/.zsh-profiles/shared/custom.zsh)\n");
    output.push_str("[ -f \"$HOME/.zsh-profiles/shared/custom.zsh\" ] && source \"$HOME/.zsh-profiles/shared/custom.zsh\"\n");

    Ok(())
}

/// Generate zimfw specific configuration
fn generate_zimfw_config(output: &mut String, manifest: &Manifest) -> Result<()> {
    output.push_str("# zimfw configuration\n");

    // Set ZIM_HOME
    output.push_str("export ZIM_HOME=\"$ZDOTDIR/.zim\"\n");
    output.push_str("\n");

    // Load plugins
    if !manifest.plugins.enabled.is_empty() {
        output.push_str("# Plugins\n");
        for plugin in &manifest.plugins.enabled {
            output.push_str(&format!("zmodule {}\n", plugin));
        }
        output.push_str("\n");
    }

    // Set theme
    if !manifest.profile.theme.is_empty() {
        output.push_str(&format!("zmodule {}\n", manifest.profile.theme));
        output.push_str("\n");
    }

    // Source zimfw
    output.push_str("source $ZIM_HOME/init.zsh\n");

    // Source shared customizations
    output.push_str("\n# Source shared customizations (edit ~/.zsh-profiles/shared/custom.zsh)\n");
    output.push_str("[ -f \"$HOME/.zsh-profiles/shared/custom.zsh\" ] && source \"$HOME/.zsh-profiles/shared/custom.zsh\"\n");

    Ok(())
}

/// Generate prezto specific configuration
fn generate_prezto_config(output: &mut String, manifest: &Manifest) -> Result<()> {
    output.push_str("# prezto configuration\n");

    // Set PREZTO_DIR
    output.push_str("export PREZTO_DIR=\"$ZDOTDIR/.zprezto\"\n");
    output.push_str("\n");

    // Load plugins
    if !manifest.plugins.enabled.is_empty() {
        output.push_str("# Prezto modules\n");
        output.push_str("zstyle ':prezto:load' pmodule \\\n");
        for (idx, plugin) in manifest.plugins.enabled.iter().enumerate() {
            if idx == manifest.plugins.enabled.len() - 1 {
                output.push_str(&format!("  '{}'\n", plugin));
            } else {
                output.push_str(&format!("  '{}' \\\n", plugin));
            }
        }
        output.push_str("\n");
    }

    // Set theme
    if !manifest.profile.theme.is_empty() {
        output.push_str(&format!("zstyle ':prezto:module:prompt' theme '{}'\n", manifest.profile.theme));
        output.push_str("\n");
    }

    // Source prezto
    output.push_str("source $PREZTO_DIR/init.zsh\n");

    // Source shared customizations
    output.push_str("\n# Source shared customizations (edit ~/.zsh-profiles/shared/custom.zsh)\n");
    output.push_str("[ -f \"$HOME/.zsh-profiles/shared/custom.zsh\" ] && source \"$HOME/.zsh-profiles/shared/custom.zsh\"\n");

    Ok(())
}

/// Generate zinit specific configuration
fn generate_zinit_config(output: &mut String, manifest: &Manifest) -> Result<()> {
    output.push_str("# zinit configuration\n");

    // Set zinit home
    output.push_str("export ZINIT_HOME=\"$ZDOTDIR/.zinit\"\n");
    output.push_str("\n");

    // Source zinit
    output.push_str("source $ZINIT_HOME/zinit.zsh\n");
    output.push_str("\n");

    // Load plugins
    if !manifest.plugins.enabled.is_empty() {
        output.push_str("# Plugins\n");
        for plugin in &manifest.plugins.enabled {
            output.push_str(&format!("zinit light {}\n", plugin));
        }
        output.push_str("\n");
    }

    // Load theme
    if !manifest.profile.theme.is_empty() {
        output.push_str(&format!("zinit light {}\n", manifest.profile.theme));
        output.push_str("\n");
    }

    // Source shared customizations
    output.push_str("# Source shared customizations (edit ~/.zsh-profiles/shared/custom.zsh)\n");
    output.push_str("[ -f \"$HOME/.zsh-profiles/shared/custom.zsh\" ] && source \"$HOME/.zsh-profiles/shared/custom.zsh\"\n");

    Ok(())
}

/// Generate zap specific configuration
fn generate_zap_config(output: &mut String, manifest: &Manifest) -> Result<()> {
    output.push_str("# zap configuration\n");

    // Set zap home
    output.push_str("export ZAP_DIR=\"$ZDOTDIR/.zap\"\n");
    output.push_str("\n");

    // Source zap
    output.push_str("source $ZAP_DIR/zap.zsh\n");
    
    // Override ZAP_DIR after sourcing to ensure our path is used
    output.push_str("export ZAP_DIR=\"$ZDOTDIR/.zap\"\n");
    output.push_str("export ZAP_PLUGIN_DIR=\"$ZAP_DIR/plugins\"\n");
    output.push_str("\n");

    // Load plugins
    if !manifest.plugins.enabled.is_empty() {
        output.push_str("# Plugins\n");
        for plugin in &manifest.plugins.enabled {
            output.push_str(&format!("plug \"{}\"\n", plugin));
        }
        output.push_str("\n");
    }

    // Load theme
    if !manifest.profile.theme.is_empty() {
        output.push_str(&format!("plug \"{}\"\n", manifest.profile.theme));
        output.push_str("\n");
    }

    // Source shared customizations
    output.push_str("# Source shared customizations (edit ~/.zsh-profiles/shared/custom.zsh)\n");
    output.push_str("[ -f \"$HOME/.zsh-profiles/shared/custom.zsh\" ] && source \"$HOME/.zsh-profiles/shared/custom.zsh\"\n");

    Ok(())
}

/// Validate generated zsh file syntax using zsh -n
///
/// Runs 'zsh -n <file>' to check syntax without executing.
/// If zsh is not available, logs a warning but does not fail.
///
/// # Arguments
///
/// * `file_path` - Path to the generated .zshrc file
///
/// # Errors
///
/// Returns error if file has syntax errors and zsh is available
fn validate_zsh_syntax(file_path: &Path) -> Result<()> {
    // Run 'zsh -n <file>' to check syntax without executing
    let output = std::process::Command::new("zsh")
        .arg("-n")
        .arg(file_path)
        .output();

    match output {
        Ok(result) if result.status.success() => {
            log::debug!("Syntax validation passed: {:?}", file_path);
            Ok(())
        }
        Ok(result) => {
            let stderr = String::from_utf8_lossy(&result.stderr);
            bail!("Generated zsh file has syntax errors:\n{}", stderr);
        }
        Err(e) => {
            log::warn!("Could not validate syntax (zsh not available): {}", e);
            Ok(()) // Don't fail if zsh not available
        }
    }
}

/// Generate .zshrc and .zshenv files from wizard selections
///
/// # Arguments
///
/// * `profile_path` - The profile directory path
/// * `framework` - Selected framework type
/// * `plugins` - List of selected plugins
/// * `theme` - Selected theme name
pub fn generate_shell_configs(
    profile_path: &Path,
    framework: &FrameworkType,
    plugins: &[String],
    theme: &str,
) -> Result<()> {
    generate_zshrc(profile_path, framework, plugins, theme)?;
    generate_zshenv(profile_path)?;
    Ok(())
}

/// Generate .zshrc file with framework initialization
fn generate_zshrc(
    profile_path: &Path,
    framework: &FrameworkType,
    plugins: &[String],
    theme: &str,
) -> Result<()> {
    let mut content = String::new();

    // Header comment
    content.push_str("# Auto-generated by zprof from profile.toml\n");
    content.push_str("# DO NOT EDIT - Changes will be overwritten\n");
    content.push_str("# Edit profile.toml and run 'zprof edit <profile>' instead\n\n");

    // Framework-specific initialization
    match framework {
        FrameworkType::OhMyZsh => {
            content.push_str(&format!("export ZSH=\"$ZDOTDIR/.oh-my-zsh\"\n"));
            content.push_str(&format!("ZSH_THEME=\"{}\"\n", theme));
            content.push_str(&format!("plugins=({})\n", plugins.join(" ")));
            content.push_str("source $ZSH/oh-my-zsh.sh\n");
        }
        FrameworkType::Zimfw => {
            content.push_str("# zimfw initialization\n");
            content.push_str(&format!("zstyle ':zim:zmodule' home '$ZDOTDIR/.zimfw'\n"));
            for plugin in plugins {
                content.push_str(&format!("zmodule {}\n", plugin));
            }
            content.push_str(&format!("zmodule {}\n", theme));
            content.push_str("source $ZDOTDIR/.zimfw/zimfw.zsh\n");
        }
        FrameworkType::Prezto => {
            content.push_str("# prezto initialization\n");
            content.push_str("source $ZDOTDIR/.zprezto/init.zsh\n");
            content.push_str(&format!("zstyle ':prezto:module:prompt' theme '{}'\n", theme));
            content.push_str(&format!("zstyle ':prezto:load' pmodule {}\n",
                plugins.iter().map(|p| format!("'{}'", p)).collect::<Vec<_>>().join(" ")));
        }
        FrameworkType::Zinit => {
            content.push_str("# zinit initialization\n");
            content.push_str("source $ZDOTDIR/.zinit/bin/zinit.zsh\n");
            for plugin in plugins {
                content.push_str(&format!("zinit light {}\n", plugin));
            }
            content.push_str(&format!("zinit light {}\n", theme));
        }
        FrameworkType::Zap => {
            content.push_str("# zap initialization\n");
            content.push_str("export ZAP_DIR=\"$ZDOTDIR/.zap\"\n");
            content.push_str("[ -f $ZAP_DIR/zap.zsh ] && source $ZAP_DIR/zap.zsh\n");
            // Override ZAP_DIR after sourcing to ensure our path is used
            content.push_str("export ZAP_DIR=\"$ZDOTDIR/.zap\"\n");
            content.push_str("export ZAP_PLUGIN_DIR=\"$ZAP_DIR/plugins\"\n");
            for plugin in plugins {
                content.push_str(&format!("plug \"{}\"\n", plugin));
            }
            content.push_str(&format!("plug \"{}\"\n", theme));
        }
    }

    // Source shared customizations
    content.push_str("\n# Source shared customizations (edit ~/.zsh-profiles/shared/custom.zsh)\n");
    content.push_str("[ -f \"$HOME/.zsh-profiles/shared/custom.zsh\" ] && source \"$HOME/.zsh-profiles/shared/custom.zsh\"\n");

    let zshrc_path = profile_path.join(".zshrc");
    std::fs::write(&zshrc_path, content)
        .with_context(|| format!("Failed to write .zshrc to {}", zshrc_path.display()))?;

    Ok(())
}

/// Generate .zshenv file for environment variables
fn generate_zshenv(profile_path: &Path) -> Result<()> {
    let mut content = String::new();

    content.push_str("# Auto-generated by zprof from profile.toml\n\n");

    // Shared history configuration
    content.push_str("export HISTFILE=\"$HOME/.zsh-profiles/shared/.zsh_history\"\n");
    content.push_str("export HISTSIZE=10000\n");
    content.push_str("export SAVEHIST=10000\n");

    let zshenv_path = profile_path.join(".zshenv");
    std::fs::write(&zshenv_path, content)
        .with_context(|| format!("Failed to write .zshenv to {}", zshenv_path.display()))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::manifest::{Manifest, ProfileSection, PluginsSection};
    use chrono::Utc;
    use std::collections::HashMap;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_generate_zshrc_oh_my_zsh() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_zshrc(
            profile_path,
            &FrameworkType::OhMyZsh,
            &["git".to_string(), "docker".to_string()],
            "robbyrussell",
        )?;

        let zshrc_path = profile_path.join(".zshrc");
        let content = fs::read_to_string(&zshrc_path)?;

        assert!(content.contains("Auto-generated by zprof"));
        assert!(content.contains("export ZSH=\"$ZDOTDIR/.oh-my-zsh\""));
        assert!(content.contains("ZSH_THEME=\"robbyrussell\""));
        assert!(content.contains("plugins=(git docker)"));
        assert!(content.contains("source $ZSH/oh-my-zsh.sh"));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_zimfw() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_zshrc(
            profile_path,
            &FrameworkType::Zimfw,
            &["git".to_string(), "fzf".to_string()],
            "pure",
        )?;

        let zshrc_path = profile_path.join(".zshrc");
        let content = fs::read_to_string(&zshrc_path)?;

        assert!(content.contains("zimfw initialization"));
        assert!(content.contains("zmodule git"));
        assert!(content.contains("zmodule fzf"));
        assert!(content.contains("zmodule pure"));

        Ok(())
    }

    #[test]
    fn test_generate_zshenv() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_zshenv(profile_path)?;

        let zshenv_path = profile_path.join(".zshenv");
        let content = fs::read_to_string(&zshenv_path)?;

        assert!(content.contains("Auto-generated by zprof"));
        assert!(content.contains("export HISTFILE"));
        assert!(content.contains("export HISTSIZE=10000"));
        assert!(content.contains("export SAVEHIST=10000"));

        Ok(())
    }

    #[test]
    fn test_generate_shell_configs() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        generate_shell_configs(
            profile_path,
            &FrameworkType::OhMyZsh,
            &["git".to_string()],
            "robbyrussell",
        )?;

        // Verify both files were created
        assert!(profile_path.join(".zshrc").exists());
        assert!(profile_path.join(".zshenv").exists());

        Ok(())
    }

    // Story 2.2 Tests: Manifest-based generation

    fn create_test_manifest(framework: &str, plugins: Vec<String>, env: HashMap<String, String>) -> Manifest {
        Manifest {
            profile: ProfileSection {
                name: "test-profile".to_string(),
                framework: framework.to_string(),
                theme: "robbyrussell".to_string(),
                created: Utc::now(),
                modified: Utc::now(),
            },
            plugins: PluginsSection {
                enabled: plugins,
            },
            env,
        }
    }

    #[test]
    fn test_escape_shell_value() {
        // Test escaping backslashes
        assert_eq!(escape_shell_value("foo\\bar"), "foo\\\\bar");

        // Test escaping double quotes
        assert_eq!(escape_shell_value("foo\"bar"), "foo\\\"bar");

        // Test escaping dollar signs
        assert_eq!(escape_shell_value("$HOME/bin"), "\\$HOME/bin");

        // Test escaping backticks
        assert_eq!(escape_shell_value("foo`cmd`bar"), "foo\\`cmd\\`bar");

        // Test multiple special characters
        assert_eq!(escape_shell_value("\\$PATH:`pwd`"), "\\\\\\$PATH:\\`pwd\\`");
    }

    #[test]
    fn test_generate_zshenv_from_manifest_basic() -> Result<()> {
        let manifest = create_test_manifest("oh-my-zsh", vec![], HashMap::new());
        let content = generate_zshenv_from_manifest(&manifest)?;

        // AC #3: Header comments
        assert!(content.contains("Auto-generated by zprof from profile.toml"));
        assert!(content.contains("DO NOT EDIT THIS FILE DIRECTLY"));
        assert!(content.contains("zprof version:"));
        assert!(content.contains("Profile: test-profile"));

        // Shared history configuration
        assert!(content.contains("export HISTFILE=\"$HOME/.zsh-profiles/shared/.zsh_history\""));
        assert!(content.contains("export HISTSIZE=10000"));
        assert!(content.contains("export SAVEHIST=10000"));

        Ok(())
    }

    #[test]
    fn test_generate_zshenv_from_manifest_with_env_vars() -> Result<()> {
        let mut env = HashMap::new();
        env.insert("EDITOR".to_string(), "vim".to_string());
        env.insert("GOPATH".to_string(), "$HOME/go".to_string());

        let manifest = create_test_manifest("oh-my-zsh", vec![], env);
        let content = generate_zshenv_from_manifest(&manifest)?;

        // AC #2: Environment variables with escaping
        assert!(content.contains("export EDITOR=\"vim\""));
        assert!(content.contains("export GOPATH=\"\\$HOME/go\""));

        Ok(())
    }

    #[test]
    fn test_generate_zshenv_special_char_escaping() -> Result<()> {
        let mut env = HashMap::new();
        env.insert("PATH".to_string(), "$HOME/bin:$PATH".to_string());
        env.insert("PROMPT".to_string(), "test`cmd`".to_string());

        let manifest = create_test_manifest("oh-my-zsh", vec![], env);
        let content = generate_zshenv_from_manifest(&manifest)?;

        // Verify special characters are escaped
        assert!(content.contains("\\$HOME"));
        assert!(content.contains("\\$PATH"));
        assert!(content.contains("\\`cmd\\`"));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_from_manifest_oh_my_zsh() -> Result<()> {
        let manifest = create_test_manifest(
            "oh-my-zsh",
            vec!["git".to_string(), "docker".to_string(), "kubectl".to_string()],
            HashMap::new(),
        );
        let content = generate_zshrc_from_manifest(&manifest)?;

        // AC #3: Header comments
        assert!(content.contains("Auto-generated by zprof from profile.toml"));
        assert!(content.contains("Framework: oh-my-zsh"));

        // AC #1: Framework initialization, plugin loading, theme activation
        assert!(content.contains("export ZSH=\"$ZDOTDIR/.oh-my-zsh\""));
        assert!(content.contains("ZSH_THEME=\"robbyrussell\""));
        assert!(content.contains("plugins=("));
        assert!(content.contains("  git"));
        assert!(content.contains("  docker"));
        assert!(content.contains("  kubectl"));
        assert!(content.contains("source $ZSH/oh-my-zsh.sh"));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_from_manifest_zimfw() -> Result<()> {
        let manifest = create_test_manifest(
            "zimfw",
            vec!["git".to_string(), "fzf".to_string()],
            HashMap::new(),
        );
        let content = generate_zshrc_from_manifest(&manifest)?;

        // AC #1: zimfw-specific configuration
        assert!(content.contains("export ZIM_HOME=\"$ZDOTDIR/.zim\""));
        assert!(content.contains("zmodule git"));
        assert!(content.contains("zmodule fzf"));
        assert!(content.contains("zmodule robbyrussell"));
        assert!(content.contains("source $ZIM_HOME/init.zsh"));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_from_manifest_prezto() -> Result<()> {
        let manifest = create_test_manifest(
            "prezto",
            vec!["git".to_string(), "syntax-highlighting".to_string()],
            HashMap::new(),
        );
        let content = generate_zshrc_from_manifest(&manifest)?;

        // AC #1: prezto-specific configuration
        assert!(content.contains("export PREZTO_DIR=\"$ZDOTDIR/.zprezto\""));
        assert!(content.contains("zstyle ':prezto:load' pmodule"));
        assert!(content.contains("'git'"));
        assert!(content.contains("'syntax-highlighting'"));
        assert!(content.contains("zstyle ':prezto:module:prompt' theme 'robbyrussell'"));
        assert!(content.contains("source $PREZTO_DIR/init.zsh"));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_from_manifest_zinit() -> Result<()> {
        let manifest = create_test_manifest(
            "zinit",
            vec!["zsh-users/zsh-autosuggestions".to_string()],
            HashMap::new(),
        );
        let content = generate_zshrc_from_manifest(&manifest)?;

        // AC #1: zinit-specific configuration
        assert!(content.contains("export ZINIT_HOME=\"$ZDOTDIR/.zinit\""));
        assert!(content.contains("source $ZINIT_HOME/zinit.zsh"));
        assert!(content.contains("zinit light zsh-users/zsh-autosuggestions"));
        assert!(content.contains("zinit light robbyrussell"));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_from_manifest_zap() -> Result<()> {
        let manifest = create_test_manifest(
            "zap",
            vec!["zsh-users/zsh-syntax-highlighting".to_string()],
            HashMap::new(),
        );
        let content = generate_zshrc_from_manifest(&manifest)?;

        // AC #1: zap-specific configuration
        assert!(content.contains("export ZAP_DIR=\"$ZDOTDIR/.zap\""));
        assert!(content.contains("source $ZAP_DIR/zap.zsh"));
        assert!(content.contains("export ZAP_PLUGIN_DIR=\"$ZAP_DIR/plugins\""));
        assert!(content.contains("plug \"zsh-users/zsh-syntax-highlighting\""));
        assert!(content.contains("plug \"robbyrussell\""));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_unsupported_framework() {
        let manifest = create_test_manifest("bash-it", vec![], HashMap::new());
        let result = generate_zshrc_from_manifest(&manifest);

        // Should return error for unsupported framework
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("Unsupported framework"));
        assert!(err_msg.contains("bash-it"));
    }

    #[test]
    fn test_generate_zshrc_empty_plugins() -> Result<()> {
        let manifest = create_test_manifest("oh-my-zsh", vec![], HashMap::new());
        let content = generate_zshrc_from_manifest(&manifest)?;

        // Should generate valid config even with no plugins
        assert!(content.contains("export ZSH="));
        assert!(content.contains("source $ZSH/oh-my-zsh.sh"));
        // Should not have plugins=() section if empty
        assert!(!content.contains("plugins=("));

        Ok(())
    }

    #[test]
    fn test_generate_zshrc_empty_theme() -> Result<()> {
        let mut manifest = create_test_manifest("oh-my-zsh", vec![], HashMap::new());
        manifest.profile.theme = String::new();
        let content = generate_zshrc_from_manifest(&manifest)?;

        // Should default to robbyrussell when theme is empty
        assert!(content.contains("ZSH_THEME=\"robbyrussell\""));

        Ok(())
    }

    #[test]
    fn test_write_generated_files_creates_directory() -> Result<()> {
        let _temp_dir = TempDir::new()?;

        // Override home dir for testing (if possible) or use temp dir structure
        // For now, we'll just test the generation functions individually
        // This is an integration test that would need mocking of dirs::home_dir()

        Ok(())
    }

    #[test]
    fn test_generated_files_are_syntactically_valid() -> Result<()> {
        // This test checks AC #5: Generated configuration is syntactically valid
        let manifest = create_test_manifest(
            "oh-my-zsh",
            vec!["git".to_string(), "docker".to_string()],
            HashMap::new(),
        );

        let zshrc_content = generate_zshrc_from_manifest(&manifest)?;
        let zshenv_content = generate_zshenv_from_manifest(&manifest)?;

        // Write to temp files for syntax validation
        let temp_dir = TempDir::new()?;
        let zshrc_path = temp_dir.path().join(".zshrc");
        let zshenv_path = temp_dir.path().join(".zshenv");

        fs::write(&zshrc_path, zshrc_content)?;
        fs::write(&zshenv_path, zshenv_content)?;

        // Try to validate syntax if zsh is available
        // This will log a warning if zsh is not available but won't fail
        validate_zsh_syntax(&zshrc_path)?;

        Ok(())
    }

    #[test]
    fn test_generation_performance() -> Result<()> {
        // AC #6: Process completes in under 1 second
        use std::time::Instant;

        let mut env = HashMap::new();
        for i in 0..50 {
            env.insert(format!("VAR_{}", i), format!("value_{}", i));
        }

        let manifest = create_test_manifest(
            "oh-my-zsh",
            vec!["git".to_string(), "docker".to_string(), "kubectl".to_string()],
            env,
        );

        let start = Instant::now();

        // Generate both files
        let _zshrc = generate_zshrc_from_manifest(&manifest)?;
        let _zshenv = generate_zshenv_from_manifest(&manifest)?;

        let duration = start.elapsed();

        // Should be much faster than 1 second (typically < 10ms)
        assert!(duration.as_millis() < 1000,
            "Generation took {}ms, should be < 1000ms",
            duration.as_millis());

        Ok(())
    }

    #[test]
    fn test_regeneration_overwrites_files() -> Result<()> {
        // AC #4: Re-generation overwrites previous files
        let temp_dir = TempDir::new()?;
        let profile_path = temp_dir.path();

        // Create initial manifest
        let manifest1 = create_test_manifest(
            "oh-my-zsh",
            vec!["git".to_string()],
            HashMap::new(),
        );

        // Generate files first time
        let zshrc_path = profile_path.join(".zshrc");
        fs::write(&zshrc_path, generate_zshrc_from_manifest(&manifest1)?)?;

        let first_content = fs::read_to_string(&zshrc_path)?;
        assert!(first_content.contains("  git"));
        assert!(!first_content.contains("  docker"));

        // Create updated manifest with different plugins
        let manifest2 = create_test_manifest(
            "oh-my-zsh",
            vec!["docker".to_string(), "kubectl".to_string()],
            HashMap::new(),
        );

        // Regenerate (overwrite)
        fs::write(&zshrc_path, generate_zshrc_from_manifest(&manifest2)?)?;

        let second_content = fs::read_to_string(&zshrc_path)?;

        // Verify old plugin is gone and new plugins are present
        assert!(!second_content.contains("  git"));
        assert!(second_content.contains("  docker"));
        assert!(second_content.contains("  kubectl"));

        Ok(())
    }
}
